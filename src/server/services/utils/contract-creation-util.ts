import { SourcifyChain } from "@ethereum-sourcify/lib-sourcify";
import { getAddress } from "ethers";
import { StatusCodes } from "http-status-codes";
import fetch from "node-fetch";
import puppeteer from "puppeteer";

const checkCreatorTx = async (
  sourcifyChain: SourcifyChain,
  address: string,
  txHash: string
): Promise<{ txHash: string; data: string }> => {
  const txRecipt = await sourcifyChain.getTxRecipt(txHash);
  const tx = await sourcifyChain.getTx(txHash);
  let data = "";

  if (txRecipt.contractAddress !== null) {
    // EOA created
    if (txRecipt.contractAddress !== address) {
      throw new Error("TxHash doesn't match the contract.");
    }
    data = tx.data;
  } else {
    // Factory created
    let traces;
    try {
      traces = await sourcifyChain.getTxTraces(txHash);
    } catch (e) {
      traces = [];
    }

    // If traces are available check, otherwise lets just trust
    if (traces.length > 0) {
      const createTraces = traces.filter(
        (trace: any) => trace.type === "create"
      );
      const createdContractAddressesInTx = createTraces.find(
        (trace) => getAddress(trace.result.address) === address
      );
      data = createdContractAddressesInTx.result.code;
      if (createdContractAddressesInTx === undefined) {
        throw new Error("TxHash doesn't match the contract.");
      }
    }
  }

  return { txHash, data };
};

/**
 * Finds the transaction that created the contract by either scraping a block explorer or querying a provided API.
 *
 * @param sourcifyChain
 * @param address
 * @returns
 */
export const getCreatorTx = async (
  sourcifyChain: SourcifyChain,
  address: string
): Promise<string | null> => {
  const contractFetchAddressFilled =
    sourcifyChain.contractFetchAddress?.replace("${ADDRESS}", address);
  const txRegex = sourcifyChain?.txRegex;

  if (!contractFetchAddressFilled) return null;

  // Chains with the new Etherscan API that returns the creation transaction hash
  if (contractFetchAddressFilled.includes("action=getcontractcreation")) {
    const response = await fetchFromApi(contractFetchAddressFilled);
    if (response?.result?.[0]?.txHash)
      if (response?.result?.[0]?.txHash) {
        // TODO @alliance-database: use a different function to check if the address was generated by the txHash provided
        await sourcifyChain.getContractCreationBytecode(
          address,
          response?.result?.[0]?.txHash as string
        );
        return response?.result?.[0]?.txHash;
      }
  }

  // TODO @alliance-database: add the `checkCreatorTx` function to all the cases
  // If there's txRegex, scrape block explorers
  if (contractFetchAddressFilled && txRegex) {
    const creatorTx = await getCreatorTxByScraping(
      contractFetchAddressFilled,
      txRegex
    );
    if (creatorTx) return creatorTx;
  }

  // Telos
  if (sourcifyChain.chainId == 40 || sourcifyChain.chainId == 41) {
    const response = await fetchFromApi(contractFetchAddressFilled);
    if (response.creation_trx) return response.creation_trx as string;
  }

  // XDC
  if (sourcifyChain.chainId == 50 || sourcifyChain.chainId == 51) {
    const response = await fetchFromApi(contractFetchAddressFilled);
    if (response.fromTxn) return response.fromTxn as string;
  }

  // Meter network
  if (sourcifyChain.chainId == 83 || sourcifyChain.chainId == 82) {
    const response = await fetchFromApi(contractFetchAddressFilled);
    if (response?.account?.creationTxHash)
      return response.account.creationTxHash as string;
  }

  // Avalanche Subnets
  if (contractFetchAddressFilled.includes("avax.network")) {
    const response = await fetchFromApi(contractFetchAddressFilled);
    if (response.nativeTransaction?.txHash)
      return response.nativeTransaction.txHash as string;
  }

  return null;
};

/**
 * Fetches the block explorer page (Etherscan, Blockscout etc.) of the contract and extracts the transaction hash that created the contract from the page with the provided regex for that explorer.
 *
 * @param fetchAddress the URL from which to fetch the page to be scrapd
 * @param txRegex regex whose first group matches the transaction hash on the page
 * @returns a promise of the tx hash that created the contract
 */
async function getCreatorTxByScraping(
  fetchAddress: string,
  txRegex: string[]
): Promise<string | null> {
  const browser = await puppeteer.launch({
    headless: "new",
    args: ["--no-sandbox"],
  });
  const page = await browser.newPage();
  const response = await page.goto(fetchAddress);
  await new Promise((r) => setTimeout(r, 3000)); // Wait for 3 seconds

  const bodyHTML = await page.evaluate(() => document.body.innerHTML);
  await browser.close();

  if (!response)
    throw new Error(
      "Scraping the creator tx failed. No response from " + fetchAddress
    );

  if (response.status() === StatusCodes.OK) {
    for (const regex of txRegex) {
      const matched = bodyHTML.match(regex);
      if (matched && matched[1]) {
        const txHash = matched[1];
        return txHash;
      }
    }
    if (bodyHTML.includes("captcha") || bodyHTML.includes("CAPTCHA")) {
      throw new Error(
        "Scraping the creator tx failed because of CAPTCHA at ${fetchAddress}"
      );
    }
  } else {
    throw new Error(
      `Scraping the creator tx failed at ${fetchAddress} because of HTTP status code ${response.status()}
      
      Try manually putting the creator tx hash in the "Creator tx hash" field.`
    );
  }
  return null;
}

async function fetchFromApi(fetchAddress: string) {
  const res = await fetch(fetchAddress);
  if (res.status === StatusCodes.OK) {
    const response = await res.json();
    return response;
  }

  throw new Error(
    `Contract creator tx could not be fetched from ${fetchAddress} because of status code ${res.status}`
  );
}
